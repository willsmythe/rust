# Recommened editor for this file: https://github.com/Microsoft/azure-pipelines-vscode
name: rust

# Note:
# for sccache to work, you'll need to provide the backend connection information
# I opted for an Azure Storage account I set up in the same region as
# the johnterickson Azure Pipelines account.
# In Pipeline Settings, I've set the following:
# SCCACHE_AZURE_CONNECTION_STRING: [secret]
# DOCKER_LAYER_CACHE_ACCOUNT_KEY: [secret]

# Note 2:
# To get sccache working, I had to build it with the Azure feature enabled
# and with openssl statically-linked for Linux.
# Here's the build (with a backpointer to source) of where the bits came from:
# https://dev.azure.com/johnterickson/rust-lang/_build/results?buildId=275

variables:
  BUILD_LINUX_OSX: 1
  BUILD_WINDOWS: 1

  # By default schannel checks revocation of certificates unlike some other SSL
  # backends, but we've historically had problems on CI where a revocation
  # server goes down presumably. See #43333 for more info
  CARGO_HTTP_CHECK_REVOKE: false
  
  # for sccache to work
  SCCACHE_AZURE_BLOB_CONTAINER: rust-sccache-1

  # for docker caching
  DOCKER_LAYER_CACHE_STORAGE_ACCOUNT: rustlangtools
  DOCKER_LAYER_CACHE_CONTAINER_NAME: docker

jobs:
  - job: linux_and_osx
    timeoutInMinutes: 600
    condition: and(succeeded(), eq(variables['BUILD_LINUX_OSX'],'1'))
    variables:
      # by default, assuming Linux; override for osx
      HOST_IMAGE: ubuntu-16.04
    strategy:
      matrix:
        x86_64-gnu-llvm-6.0:
          RUST_BACKTRACE: 1
        # if: type = pull_request OR branch = auto

        dist-x86_64-linux:
          DEPLOY: 1
        # if: branch = try OR branch = auto

        # "alternate" deployments, these are "nightlies" but have LLVM assertions
        # turned on, they're deployed to a different location primarily for
        # additional testing.
        dist-x86_64-linux-alt:
          IMAGE: dist-x86_64-linux
          DEPLOY_ALT: 1
        # if: branch = try OR branch = auto

        dist-x86_64-apple-alt:
          HOST_IMAGE: macos-10.13
          RUST_CHECK_TARGET: dist
          RUST_CONFIGURE_ARGS: --enable-extended --enable-profiler --enable-lldb --set rust.jemalloc
          SRC: .
          DEPLOY_ALT: 1
          RUSTC_RETRY_LINKER_ON_SEGFAULT: 1
          MACOSX_DEPLOYMENT_TARGET: 10.7
          NO_LLVM_ASSERTIONS: 1
          NO_DEBUG_ASSERTIONS: 1
        # if: branch = auto

        # macOS builders. These are placed near the beginning because they are very
        # slow to run.

        # OSX builders running tests, these run the full test suite.
        # NO_DEBUG_ASSERTIONS=1 to make them go faster, but also do have some
        # runners that run `//ignore-debug` tests.
        #
        # Note that the compiler is compiled to target 10.8 here because the Xcode
        # version that we're using, 8.2, cannot compile LLVM for OSX 10.7.
        x86_64-apple:
          HOST_IMAGE: macos-10.13
          RUST_CHECK_TARGET: check
          RUST_CONFIGURE_ARGS: --build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc
          SRC: .
          RUSTC_RETRY_LINKER_ON_SEGFAULT: 1
          MACOSX_DEPLOYMENT_TARGET: 10.8
          MACOSX_STD_DEPLOYMENT_TARGET: 10.7
          NO_LLVM_ASSERTIONS: 1
          NO_DEBUG_ASSERTIONS: 1
        # if: branch = auto

        i686-apple:
          HOST_IMAGE: macos-10.13
          RUST_CHECK_TARGET: check 
          RUST_CONFIGURE_ARGS: --build=i686-apple-darwin --set rust.jemalloc
          SRC: .
          RUSTC_RETRY_LINKER_ON_SEGFAULT: 1
          MACOSX_DEPLOYMENT_TARGET: 10.8
          MACOSX_STD_DEPLOYMENT_TARGET: 10.7
          NO_LLVM_ASSERTIONS: 1
          NO_DEBUG_ASSERTIONS: 1
        # if: branch = auto

        dist-i686-apple:
          HOST_IMAGE: macos-10.13
          RUST_CHECK_TARGET: dist
          RUST_CONFIGURE_ARGS: --build=i686-apple-darwin --enable-full-tools --enable-profiler --enable-lldb --set rust.jemalloc
          SRC: .
          DEPLOY: 1
          RUSTC_RETRY_LINKER_ON_SEGFAULT: 1
          MACOSX_DEPLOYMENT_TARGET: 10.7
          NO_LLVM_ASSERTIONS: 1
          NO_DEBUG_ASSERTIONS: 1
          DIST_REQUIRE_ALL_TOOLS: 1
        # if: branch = auto

        dist-x86_64-apple:
          HOST_IMAGE: macos-10.13
          RUST_CHECK_TARGET: dist
          RUST_CONFIGURE_ARGS: --target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --enable-lldb --set rust.jemalloc
          SRC: .
          DEPLOY: 1
          RUSTC_RETRY_LINKER_ON_SEGFAULT: 1
          MACOSX_DEPLOYMENT_TARGET: 10.7
          NO_LLVM_ASSERTIONS: 1
          NO_DEBUG_ASSERTIONS: 1
          DIST_REQUIRE_ALL_TOOLS: 1
        # if: branch = auto

        # Linux builders, remaining docker images
        
        arm-android:
          DUMMY_IGNORE_ME: 1
        # if: branch = auto

        armhf-gnu:
          DUMMY_IGNORE_ME: 1
        # if: branch = auto

        dist-various-1:
          DEPLOY: 1
        # if: branch = auto

        dist-various-2:
          DEPLOY: 1
        # if: branch = auto

        dist-aarch64-linux:
          DEPLOY: 1
        # if: branch = auto

        dist-android:
          DEPLOY: 1
        # if: branch = auto

        dist-arm-linux:
          DEPLOY: 1
        # if: branch = auto

        dist-armhf-linux:
          DEPLOY: 1
        # if: branch = auto

        dist-armv7-linux:
          DEPLOY: 1
        # if: branch = auto

        dist-i586-gnu-i586-i686-musl:
          DEPLOY: 1
        # if: branch = auto

        dist-i686-freebsd:
          DEPLOY: 1
        # if: branch = auto

        dist-i686-linux:
          DEPLOY: 1
        # if: branch = auto

        dist-mips-linux:
          DEPLOY: 1
        # if: branch = auto

        dist-mips64-linux:
          DEPLOY: 1
        # if: branch = auto

        dist-mips64el-linux:
          DEPLOY: 1
        # if: branch = auto

        dist-mipsel-linux:
          DEPLOY: 1
        # if: branch = auto

        dist-powerpc-linux:
          DEPLOY: 1
        # if: branch = auto

        dist-powerpc64-linux:
          DEPLOY: 1
        # if: branch = auto

        dist-powerpc64le-linux:
          DEPLOY: 1
        # if: branch = auto

        dist-s390x-linux:
          DEPLOY: 1
        # if: branch = auto

        dist-x86_64-freebsd:
          DEPLOY: 1
        # if: branch = auto

        dist-x86_64-musl:
          DEPLOY: 1
        # if: branch = auto

        dist-x86_64-netbsd:
          DEPLOY: 1
        # if: branch = auto

        asmjs:
          DEPLOY: 0
        # if: branch = auto

        i686-gnu:
          DEPLOY: 0
        # if: branch = auto

        i686-gnu-nopt:
          DEPLOY: 0
        # if: branch = auto

        test-various:
          DEPLOY: 0
        # if: branch = auto

        x86_64-gnu:
          DEPLOY: 0
        # if: branch = auto

        x86_64-gnu-full-bootstrap:
          DEPLOY: 0
        # if: branch = auto

        x86_64-gnu-aux:
          DEPLOY: 0
        # if: branch = auto

        x86_64-gnu-tools:
          DEPLOY: 0
        # if: branch = auto OR (type = pull_request AND commit_message =~ /(?i:^update.*\b(rls|rustfmt|clippy|miri|cargo)\b)/)

        x86_64-gnu-debug:
          DEPLOY: 0
        # if: branch = auto

        x86_64-gnu-nopt:
          DEPLOY: 0
        # if: branch = auto

        x86_64-gnu-distcheck:
          DEPLOY: 0
        # if: branch = auto

        mingw-check:
          DEPLOY: 0
        # if: type = pull_request OR branch = auto

    pool:
      vmImage: $[ variables['HOST_IMAGE'] ] 
    steps:
      - script: |
          printenv | sort
        displayName: dump env vars

      - script: |
          sudo apt install gdb
        displayName: install gdb
        condition: and(succeeded(), eq(variables['Agent.OS'],'Linux'))
      
      - script: |
          pip install --user awscli
          export PATH=$PATH:$HOME/.local/bin:$HOME/Library/Python/2.7/bin/
          mkdir -p $HOME/rustsrc
          echo "##vso[task.setvariable variable=PATH;]$PATH"
        displayName:  before_install

      # FIXME(#46924): these two commands are required to enable IPv6,
      # they shouldn't exist, please revert once more official solutions appeared.
      # see https://github.com/travis-ci/travis-ci/issues/8891#issuecomment-353403729
      - script: |
          echo '{"ipv6":true,"fixed-cidr-v6":"fd9a:8454:6789:13f7::/64"}' | sudo tee /etc/docker/daemon.json
          sudo service docker restart
        condition: and(succeeded(), eq(variables['Agent.OS'],'Linux'))
        displayName: Enable IPv6
        
      - script: |
          curl -fo $HOME/stamp https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-03-17-stamp-x86_64-unknown-linux-musl
          chmod +x $HOME/stamp
          export PATH=$PATH:$HOME
          echo "##vso[task.setvariable variable=PATH;]$PATH"
        condition: and(succeeded(), eq(variables['Agent.OS'],'Linux'))
        displayName: install linux
      - script: |
          brew update
          brew install xz
          brew install swig
        condition: and(succeeded(), and(eq(variables['Agent.OS'],'Darwin'), eq(variables['RUST_CHECK_TARGET'],'dist')))
        displayName: install osx - brew install xz and swig
      - script: |
          echo Use sccache built with Azure Storage support
          curl -fo /usr/local/bin/sccache https://rustlangtools.blob.core.windows.net/public/stable-x86_64-apple-darwin.sccache
          chmod +x /usr/local/bin/sccache
          curl -fo /usr/local/bin/stamp https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-03-17-stamp-x86_64-apple-darwin
          chmod +x /usr/local/bin/stamp
          curl -f http://releases.llvm.org/7.0.0/clang+llvm-7.0.0-x86_64-apple-darwin.tar.xz | tar xJf - 
          export CC=`pwd`/clang+llvm-7.0.0-x86_64-apple-darwin/bin/clang
          echo "##vso[task.setvariable variable=CC;]$CC"
          export CXX=`pwd`/clang+llvm-7.0.0-x86_64-apple-darwin/bin/clang++
          echo "##vso[task.setvariable variable=CXX;]$CXX"
          export AR=ar
          echo "##vso[task.setvariable variable=AR;]$AR"
        condition: and(succeeded(), eq(variables['Agent.OS'],'Darwin'))
        displayName: install osx
      
      - script: |
          echo "#### Disk usage before running script:"
          df -h
          du . | sort -nr | head -n100
        displayName: check disk usage

      - script: |
          set -x
          export RUN_SCRIPT="$BUILD_SOURCESDIRECTORY/src/ci/init_repo.sh . $HOME/rustsrc && src/ci/run.sh"
          echo "$RUN_SCRIPT"
          echo "##vso[task.setvariable variable=RUN_SCRIPT]$RUN_SCRIPT"
          echo "##vso[task.setvariable variable=TRAVIS_OS_NAME;]osx"
        condition: and(succeeded(), eq(variables['Agent.OS'],'Darwin'))
        displayName: prepare run script for osx

      - script: |
          set -x
          [ -z "$IMAGE" ] && export IMAGE=$SYSTEM_JOBDISPLAYNAME
          export RUN_SCRIPT="$BUILD_SOURCESDIRECTORY/src/ci/init_repo.sh . $HOME/rustsrc && src/ci/docker/run.sh $IMAGE"
          echo "$RUN_SCRIPT"
          echo "##vso[task.setvariable variable=IMAGE]$IMAGE"
          echo "##vso[task.setvariable variable=RUN_SCRIPT]$RUN_SCRIPT"
          echo "##vso[task.setvariable variable=TRAVIS_OS_NAME;]linux"
        condition: and(succeeded(), eq(variables['Agent.OS'],'Linux'))
        displayName: prepare run script for linux
      
      - script: |
          sudo sh -c 'echo "/checkout/obj/cores/core.%p.%E" > /proc/sys/kernel/core_pattern'
        condition: and(succeeded(), eq(variables['Agent.OS'],'Linux'))
        displayName: Enable core dump on Linux

      - script: |
          git clone --depth=1 https://github.com/rust-lang-nursery/rust-toolstate.git
          cd rust-toolstate
          python2.7 "$BUILD_SOURCESDIRECTORY/src/tools/publish_toolstate.py" "$(git rev-parse HEAD)" "$(git log --format=%s -n1 HEAD)" "" ""
          cd ..
          rm -rf rust-toolstate
        condition: and(succeeded(), eq(variables['IMAGE'],'mingw-check'))
        displayName: verify the publish_toolstate script works

      # Log time information from this machine and an external machine for insight into possible
      # clock drift. Timezones don't matter since relative deltas give all the necessary info.
      - script: |
          date && (curl -fs --head https://google.com | grep ^Date: | sed 's/Date: //g' || true)
        displayName: check for clock skew before

      - script: |
          echo RUN_SCRIPT="$RUN_SCRIPT"
          export RUN_SCRIPT="${RUN_SCRIPT//\'}"
          echo RUN_SCRIPT="$RUN_SCRIPT"

          echo TRAVIS_OS_NAME="$TRAVIS_OS_NAME"
          export TRAVIS_OS_NAME="${TRAVIS_OS_NAME//\'}"
          echo TRAVIS_OS_NAME="$TRAVIS_OS_NAME"

          echo IMAGE="$IMAGE"
          export IMAGE="${IMAGE//\'}"
          echo IMAGE="$IMAGE"

          echo Emulate for CiEnv
          export CI="true"
          export TRAVIS="true"
          export CI_JOB_NAME="$SYSTEM_JOBDISPLAYNAME"

          if [ "$DISABLE_SCCACHE" == "1" ]; then unset SCCACHE_AZURE_CONNECTION_STRING; fi

          printenv | sort | grep -v SCCACHE_AZURE_CONNECTION_STRING
          which sccache
          stamp sh -x -c "$RUN_SCRIPT"
        displayName: run script
        env:
          # explicitly decrypt secret variables
          # see https://docs.microsoft.com/en-us/azure/devops/pipelines/process/variables?view=azure-devops&tabs=yaml%2Cbatch
          SCCACHE_AZURE_CONNECTION_STRING: $(SCCACHE_AZURE_CONNECTION_STRING)
          DOCKER_LAYER_CACHE_ACCOUNT_KEY: $(DOCKER_LAYER_CACHE_ACCOUNT_KEY)

      - script: |
          date && (curl -fs --head https://google.com | grep ^Date: | sed 's/Date: //g' || true)
        displayName: check for clock skew after

  - job: windows
    timeoutInMinutes: 600
    condition: and(succeeded(), eq(variables['BUILD_WINDOWS'],'1'))
    variables:
      HOST_IMAGE: vs2017-win2016
    strategy:
      matrix:
        # 32/64 bit MSVC tests
        x86_64-msvc:
          MSYS_BITS: 64
          RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler
          SCRIPT: python x.py test
          CI_JOB_NAME: x86_64-msvc
        i686-msvc-1:
          MSYS_BITS: 32
          RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc
          SCRIPT: make appveyor-subset-1
          CI_JOB_NAME: i686-msvc-1
        i686-msvc-2:
          MSYS_BITS: 32
          RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc
          SCRIPT: make appveyor-subset-2
          CI_JOB_NAME: i686-msvc-2
        # MSVC aux tests
        x86_64-msvc-aux:
          MSYS_BITS: 64
          RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1
          RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc
          CI_JOB_NAME: x86_64-msvc-aux
        x86_64-msvc-cargo:
          MSYS_BITS: 64
          SCRIPT: python x.py test src/tools/cargotest src/tools/cargo
          RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc
          VCVARS_BAT: vcvars64.bat
          CI_JOB_NAME: x86_64-msvc-cargo
        # MSVC tools tests
        x86_64-msvc-tools:
          MSYS_BITS: 64
          SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstates.json windows
          RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstates.json --enable-test-miri
          CI_JOB_NAME: x86_64-msvc-tools

        # 32/64-bit MinGW builds.
        #
        # We are using MinGW with posix threads since LLVM does not compile with
        # the win32 threads version due to missing support for C++'s std::thread.
        #
        # Instead of relying on the MinGW version installed on appveryor we download
        # and install one ourselves so we won't be surprised by changes to appveyor's
        # build image.
        #
        # Finally, note that the downloads below are all in the `rust-lang-ci` S3
        # bucket, but they cleraly didn't originate there! The downloads originally
        # came from the mingw-w64 SourceForge download site. Unfortunately
        # SourceForge is notoriously flaky, so we mirror it on our own infrastructure.
        i686-mingw-1:
          MSYS_BITS: 32
          RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu
          SCRIPT: make appveyor-subset-1
          MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror
          MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z
          MINGW_DIR: mingw32
          CI_JOB_NAME: i686-mingw-1
        i686-mingw-2:
          MSYS_BITS: 32
          RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu
          SCRIPT: make appveyor-subset-2
          MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror
          MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z
          MINGW_DIR: mingw32
          CI_JOB_NAME: i686-mingw-2
        x86_64-mingw:
          MSYS_BITS: 64
          SCRIPT: python x.py test
          RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu
          MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror
          MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z
          MINGW_DIR: mingw64
          CI_JOB_NAME: x86_64-mingw

        # 32/64 bit MSVC and GNU deployment
        dist-x86_64-msvc:
          RUST_CONFIGURE_ARGS: >
            --build=x86_64-pc-windows-msvc
            --target=x86_64-pc-windows-msvc,aarch64-pc-windows-msvc
            --enable-full-tools
            --enable-profiler
          SCRIPT: python x.py dist
          DIST_REQUIRE_ALL_TOOLS: 1
          DEPLOY: 1
          CI_JOB_NAME: dist-x86_64-msvc
        dist-i686-msvc:
          RUST_CONFIGURE_ARGS: >
            --build=i686-pc-windows-msvc
            --target=i586-pc-windows-msvc
            --enable-full-tools
            --enable-profiler
          SCRIPT: python x.py dist
          DIST_REQUIRE_ALL_TOOLS: 1
          DEPLOY: 1
          CI_JOB_NAME: dist-i686-msvc
        dist-i686-mingw:
          MSYS_BITS: 32
          RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-full-tools
          SCRIPT: python x.py dist
          MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror
          MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z
          MINGW_DIR: mingw32
          DIST_REQUIRE_ALL_TOOLS: 1
          DEPLOY: 1
          CI_JOB_NAME: dist-i686-mingw
        dist-x86_64-mingw:
          MSYS_BITS: 64
          SCRIPT: python x.py dist
          RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-full-tools
          MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror
          MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z
          MINGW_DIR: mingw64
          DIST_REQUIRE_ALL_TOOLS: 1
          DEPLOY: 1
          CI_JOB_NAME: dist-x86_64-mingw

        # "alternate" deployment, see .travis.yml for more info
        dist-x86_64-msvc-alt:
          MSYS_BITS: 64
          RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended --enable-profiler
          SCRIPT: python x.py dist
          DEPLOY_ALT: 1
          CI_JOB_NAME: dist-x86_64-msvc-alt

    pool:
      vmImage: $[ variables['HOST_IMAGE'] ] 
    steps:
      - script: |
          set
        displayName: dump env vars

      - script: |
          echo ON
          @"%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command "iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))" && SET "PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin"
          echo ##vso[task.setvariable variable=PATH;]%PATH%
        displayName: install choco
        condition: and(succeeded(), ne(variables['HOST_IMAGE'],'vs2017-win2016'))

      - script: |
          echo ON
          IF NOT "%HOST_IMAGE%"=="vs2017-win2016" choco install 7zip.install -y
          set PATH=%PATH%;C:\Program Files\7-Zip
          echo ##vso[task.setvariable variable=PATH;]%PATH%
          7z
        displayName: Add 7-zip to path

      - script: |
          @echo on
          choco install msys2 --params="/InstallDir:C:\msys64 /NoPath" -y
          set PATH=C:\msys64\usr\bin;%PATH%
          pacman -S --noconfirm --needed base-devel ca-certificates make diffutils tar 
          IF "%MINGW_URL%"=="" (
            IF "%MSYS_BITS%"=="32" pacman -S --noconfirm --needed mingw-w64-i686-toolchain mingw-w64-i686-cmake mingw-w64-i686-gcc mingw-w64-i686-python2
            IF "%MSYS_BITS%"=="64" pacman -S --noconfirm --needed mingw-w64-x86_64-toolchain mingw-w64-x86_64-cmake mingw-w64-x86_64-gcc mingw-w64-x86_64-python2
          )
          where rev
          rev --help
          where make
        displayName: install msys2

      # If we need to download a custom MinGW, do so here and set the path
      # appropriately.
      #
      # Note that this *also* means that we're not using what is typically
      # /mingw32/bin/python2.7.exe, which is a "correct" python interpreter where
      # /usr/bin/python2.7.exe is not. To ensure we use the right interpreter we
      # move `C:\Python27` ahead in PATH and then also make sure the `python2.7.exe`
      # file exists in there (which it doesn't by default).
      - script: |
          echo ON
          powershell -Command "iwr -outf %MINGW_ARCHIVE% %MINGW_URL%/%MINGW_ARCHIVE%"
          7z x -y %MINGW_ARCHIVE% > nul
          set PATH=%CD%\%MINGW_DIR%\bin;C:\msys64\usr\bin;%PATH%
          echo ##vso[task.setvariable variable=PATH;]%PATH%
        condition: and(succeeded(), ne(variables['MINGW_URL'],''))
        displayName: Download custom MinGW

      # If we're compiling for MSVC then we, like most other distribution builders,
      # switch to clang as the compiler. This'll allow us eventually to enable LTO
      # amongst LLVM and rustc. Note that we only do this on MSVC as I don't think
      # clang has an output mode compatible with MinGW that we need. If it does we
      # should switch to clang for MinGW as well!
      #
      # Note that the LLVM installer is an NSIS installer
      #
      # Original downloaded here came from
      # http://releases.llvm.org/7.0.0/LLVM-7.0.0-win64.exe
      - script: |
          echo ON
          powershell -Command "iwr -outf LLVM-7.0.0-win64.exe https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/LLVM-7.0.0-win64.exe"
          .\LLVM-7.0.0-win64.exe /S /NCRC /D=C:\clang-rust
          set RUST_CONFIGURE_ARGS=%RUST_CONFIGURE_ARGS% --set llvm.clang-cl=C:\clang-rust\bin\clang-cl.exe
          echo ##vso[task.setvariable variable=RUST_CONFIGURE_ARGS;]%RUST_CONFIGURE_ARGS%
        condition: and(succeeded(), eq(variables['MINGW_URL'],''))
        displayName: Download clang

      # Here we do a pretty heinous thing which is to mangle the MinGW installation
      # we just had above. Currently, as of this writing, we're using MinGW-w64
      # builds of gcc, and that's currently at 6.3.0. We use 6.3.0 as it appears to
      # be the first version which contains a fix for #40546, builds randomly
      # failing during LLVM due to ar.exe/ranlib.exe failures.
      #
      # Unfortunately, though, 6.3.0 *also* is the first version of MinGW-w64 builds
      # to contain a regression in gdb (#40184). As a result if we were to use the
      # gdb provided (7.11.1) then we would fail all debuginfo tests.
      #
      # In order to fix spurious failures (pretty high priority) we use 6.3.0. To
      # avoid disabling gdb tests we download an *old* version of gdb, specifically
      # that found inside the 6.2.0 distribution. We then overwrite the 6.3.0 gdb
      # with the 6.2.0 gdb to get tests passing.
      #
      # Note that we don't literally overwrite the gdb.exe binary because it appears
      # to just use gdborig.exe, so that's the binary we deal with instead.
      - script: |
          echo ON
          powershell -Command "iwr -outf 2017-04-20-%MSYS_BITS%bit-gdborig.exe %MINGW_URL%/2017-04-20-%MSYS_BITS%bit-gdborig.exe"
          mv 2017-04-20-%MSYS_BITS%bit-gdborig.exe %MINGW_DIR%\bin\gdborig.exe
        condition: and(succeeded(), ne(variables['MINGW_URL'],''))
        displayName: Override with 6.3.0 gdb with 6.2.0 gdb
      
      # Otherwise pull in the MinGW installed on appveyor
      - script: |
          echo ON
          echo Find mingw
          set PATH | findstr /i msys
          set PATH | findstr /i mingw
          set PATH=C:\msys64\mingw%MSYS_BITS%\bin;C:\msys64\usr\bin;%PATH%
          echo ##vso[task.setvariable variable=PATH;]%PATH%
        condition: and(succeeded(), eq(variables['MINGW_URL'],''))
        displayName: Add MinGW to path

      - script: |
          echo ON
          copy C:\Python27amd64\python.exe C:\Python27amd64\python2.7.exe
          set PATH=C:\Python27amd64;%PATH%
          echo ##vso[task.setvariable variable=PATH;]%PATH%
        displayName: Prefer the "native" Python as LLVM has trouble building with MSYS sometimes

      - script: |
          echo ON
          echo Use Sccache built with Azure Storage support
          powershell -Command "iwr -outf sccache.exe https://rustlangtools.blob.core.windows.net/public/stable-x86_64-pc-windows-msvc.sccache.exe"
          set PATH=%PATH%;%CD%
          where sccache
          echo ##vso[task.setvariable variable=PATH;]%PATH%
        displayName: Download and install sccache

      # Note that this is originally from the github releases patch of Ninja
      - script: |
          echo ON
          powershell -Command "iwr -outf 2017-03-15-ninja-win.zip https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-03-15-ninja-win.zip"
          7z x 2017-03-15-ninja-win.zip
          set RUST_CONFIGURE_ARGS=%RUST_CONFIGURE_ARGS% --enable-ninja
          echo ##vso[task.setvariable variable=RUST_CONFIGURE_ARGS;]%RUST_CONFIGURE_ARGS%
          REM - set PATH=%PATH%;%CD% -- this already happens above for sccache
        displayName: Download and install ninja

      - script: |
          echo ON
          powershell -Command "iwr -outf 2017-08-22-is.exe https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-08-22-is.exe"
          2017-08-22-is.exe /VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-
          set PATH=C:\Program Files (x86)\Inno Setup 5;%PATH%
          echo ##vso[task.setvariable variable=PATH;]%PATH%
        displayName: Install InnoSetup to get `iscc` used to produce installers

      - script: |
          echo ON
          powershell -Command "iwr -outf 2017-05-15-Handle.zip https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-05-15-Handle.zip"
          mkdir handle
          7z x -ohandle 2017-05-15-Handle.zip
          set PATH=%PATH%;%CD%\handle
          handle.exe -accepteula -help
          echo ##vso[task.setvariable variable=PATH;]%PATH%
        displayName: Help debug some handle issues on AppVeyor

      - script: |
          echo ON

          echo Emulate for CiEnv
          set CI=true
          set APPVEYOR=True

          REM echo Since we only need rev for a doc-build, just make a fake one as installing
          REM echo msys2 caused more trouble
          REM echo https://github.com/johnterickson/rust/issues/5
          REM copy /y %WINDIR%\system32\PING.EXE rev.exe
          REM other doc-builds require a working rev
          REM https://github.com/rust-lang/rust/blob/79d8a0fcefa5134db2a94739b1d18daa01fc6e9f/src/libstd/process.rs line 1056

          REM echo force the specific VS version https://github.com/johnterickson/rust/issues/8
          IF "%VCVARS_BAT%" NEQ "" ( 
            CALL "C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\VC\Auxiliary\Build\%VCVARS_BAT%"
          )

          echo Check enviornment
          set PATH
          set RUST_CONFIGURE_ARGS
          where sccache
          where rev
          set | findstr /v SCCACHE_AZURE_CONNECTION_STRING

          echo temporary hack until we get more space
          echo THIS WILL PROBABLY MAKE THINGS SLOW
          mkdir c:\MORE_SPACE
          mklink /J build c:\MORE_SPACE

          if not exist D:\cache\rustsrc\NUL mkdir D:\cache\rustsrc
          sh src/ci/init_repo.sh . /d/cache/rustsrc
          set SRC=.
          set NO_CCACHE=1

          echo if this fails, it may have been because of a full disk.
          echo dump the drive to see what's taking up space
          sh src/ci/run.sh
          set RESULT=%ERRORLEVEL%
          if NOT "%RESULT%"=="0" dir /s d:\
          exit /b %RESULT%
        displayName: test_script
        env:
          # explicitly decrypt secret variables
          # see https://docs.microsoft.com/en-us/azure/devops/pipelines/process/variables?view=azure-devops&tabs=yaml%2Cbatch
          SCCACHE_AZURE_CONNECTION_STRING: $(SCCACHE_AZURE_CONNECTION_STRING)

